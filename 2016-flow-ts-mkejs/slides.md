## Static Type Analysis in JavaScript

<hr />

### Flow or TypeScript: Pick One

Note:
Quick synopsis - Flow/TS is one of the things that is making JS
development actually palatable.

---

### Who's this clown?

* Samuel Reed - [STRML.net](http://strml.net)
* In Milwaukee, WI, previously Hong Kong & Washington DC
* Frontend developer for 10 years
* CTO and Co-Founder of [BitMEX](https://www.bitmex.com), the Bitcoin Mercantile Exchange

Note:
We use Babel/Flow in our webservers & frontend application
(and not our trading engine, please).

---

## Dynamic Languages

```js
function reticulateSplines(spline, opts) { }
```

![WTF](/img/jackie.jpg)

Note: Dynamic languages are difficult.

It's difficult to trace values, method signatures, return types etc.
JSDoc, Closure Compiler, etc try to solve this with documentation

Linters try to help us not forget vars

---

### Coercions I Have Known And Loved (CIHKAL)

```js
[] + [] // ''

[] + {} // '[object Object]'

{} + [] // 0

{} + {} // NaN
```
![](/img/wat1.gif) <!-- .element: class="fragment" -->

Note:
Lots of you have seen the "Wat" talk.

Coercion is your enemy - it makes functions that should error
just keep on working.

JS is 21 - Brendan Eich, 1995, making the monkey dance

---

### Why Type Your Applications?

* Everyone's Doing it <!-- .element: class="fragment fade-out" -->
* Predictability <!-- .element: class="fragment" -->
* Reliability <!-- .element: class="fragment" -->
* Refactoring with confidence <!-- .element: class="fragment" -->

---

### Typing is as Important as Testing

*What's the real goal?* <!-- .element: class="fragment" -->

* Shipping fewer bugs to production <!-- .element: class="fragment" -->
* Ease of development / Intellisense <!-- .element: class="fragment" -->
* Ease of use (autogenerated docs, type interfaces) <!-- .element: class="fragment" -->

<blockquote class="fragment"><b>Make the computer work for you.</b></blockquote>

---

### History

JSDoc and Google Closure tried to solve some of these problems.

```javascript
// JSDoc/Closure
/**
 * Do stuff. Not guaranteed to work.
 *
 * @this {HTMLElement}
 * @param data {Object} Data bag.
 * @param [data.enabled] {?boolean} Enabled flag.
 * @param [data.count] {?number} Iterations.
 * @return number The iterations performed.
 */
function doStuff(data) {/* ... */}

// Closure
/** @type {MyType} */ (valueExpression)
```

Note:
JSDoc is verbose, gets out of date with the application

Google Closure improved on this massively but saw relatively little uptake

Closure is a platform, not just a typechecker. You have to buy-in all the way

Closure released 2009

---

### Changes Break Applications

```js
function greetUser(user) {
  showModal({
    title: 'Hi, ' + user.firstname + ' ' + user.lastname + '!',
    body: 'Welcome to my buggy site!'
  })
}
```

* <!-- .element: class="fragment" --> What can go wrong?
* <!-- .element: class="fragment" --> Refactoring: `user.name`
  * `"Hi, undefined undefined!"`
* <!-- .element: class="fragment" --> Modal may require an `id`

![](/img/thanksobama.gif) <!-- .element: class="fragment" -->

Note: Let's look looking at concrete examples.

Refactoring (and breaking) this code could feel like this.

---

### Keeping Track of Changing Code

> A preview of Flow


<iframe
  data-src="http://localhost:4000/try/#0C4TwDgpgBAqgzhATlAvFA3gKClAZgS0TmADsBDAWwgC4pjF8SBzAGmygBszjyrb7GTTAF8A3Jky4AriQDGwfAHsSdABaKA7gFlFAEzIcAFGURM4tdAuAcadYA2YsoAIz0h+9wcICUGdgHp-KAA6UKgRcUkZeSUVJkQICGB4JEMpBERaFMRfLBw4dW09A0M8nCgrG1oAcgAJfCdqqABqKHSkYIIiUkpoVqam1vbEYK4eXrZylzcagHUIDllFKgrFKAoQFykmJk24fGAIAEJq9h8RIA"
  width="90%"
  height="600px"
></iframe>

Note: Let's look at those changes from before.

user.name, modal id
---

### Inference

<iframe
  data-src="http://localhost:4000/try/#0GYVwdgxgLglg9mABMOcAUAPAlIg3gKEUQCcBTKEYpDRAKkQEYAGAbnwF998V0ByACVIAbIXAA0iAO5xiQgCYBCXlhZA"
  width="90%"
  height="600px"
></iframe>

Note: Without any definitions, Flow caught this

It knows what `*` means and uses it. It also tracks the return type.

Try calling .trim()

---

### What's in a Type System?

* <!-- .element: class="fragment" --> Explicit type annotations
* <!-- .element: class="fragment" --> Tracing of control flow / type inference
  <div class="fragment">![](/img/boring_work.gif)</div>
* <!-- .element: class="fragment" --> Interface/external lib support
* <!-- .element: class="fragment" --> Annotation stripping

Note: Control flow - auto types.

Java type system requires typing EVERYTHING

---

### TypeScript vs Flow

<!-- .page: style="width: 100%" -->

<div style="display: flex">
<div style="width: 50%">
  <h4>TypeScript</h4>
  <ul>
    <li class="fragment">Compiler + Type Checker</li>
    <li class="fragment">TypeScript is not JavaScript, has different semantics</li>
    <li class="fragment">Written in TypeScript @ Microsoft</li>
  </ul>
</div>

<div style="width: 50%">
  <h4>Flow</h4>
  <ul>
    <li class="fragment">Type Checker</li>
    <li class="fragment">Used like a linter</li>
    <li class="fragment">Easier to integrate</li>
    <li class="fragment">Write JavaScript with type annotations</li>
    <li class="fragment">Annotations can be comments</li>
      <pre class="fragment"><code class="lang-js javascript">
        function add(a/\*:number\*/, b/\*:number\*/) { }
      </code></pre>
    <li class="fragment">Written in OCaml @ Facebook</li>
    <img src="/img/OCaml_logo.png" style="background: white; width: 200px" class="fragment" />
  </ul>
</div>
</div>

Note: Rust is self-hosting

Objective Caml

"CAML" originally stood for Categorical Abstract Machine Language,

---

### Why is TypeScript a Compiler?

* <!-- .element: class="fragment" --> TypeScript was first:
  * <!-- .element: class="fragment" --> Open-sourced Sep 2012, originally on CodePlex
    * No public history before Sep 2012
    * Moved to GitHub Jul 2014
  * <!-- .element: class="fragment" --> Predates Babel by 4 years (Babel: Sep 2014)
  * <!-- .element: class="fragment" --> TS developers needed a compiler to do the type annotations

* <!-- .element: class="fragment" --> Flow: [Oct 30, 2014](https://github.com/facebook/flow/commit/49820636495b6e36752079117b9e7c34e5c4fc7b)
  * <!-- .element: class="fragment" --> Developed just a month after Babel (previously 6to5)
  * <!-- .element: class="fragment" --> Relied on react-tools, the old JSX transformer
  * <!-- .element: class="fragment" --> Switched to Babel in 2015

Note: List of differences between project structure

---

### TypeScript 2.0

* <!-- .element: class="fragment" --> Improved JS Interop (`.js` extension)
* <!-- .element: class="fragment" --> Import Untyped js (1.8)
* <!-- .element: class="fragment" --> Supports Nullable Types (`string | null`)
* <!-- .element: class="fragment" --> Control Flow Analysis
* <!-- .element: class="fragment" --> `this` Types for Functions (not in Flow!)
* <!-- .element: class="fragment" --> Tagged Unions
* <!-- .element: class="fragment" --> Read-only Properties (not in Flow!)
* <!-- .element: class="fragment" --> `never` Type (simulable in Flow via `string & number`)

Note: Mention how Flow was very much superior before 2.0 - nullable types, control flow tracking, etc

TS pre-2.0 didn't have ?string, null, undefined, had void but not usable for this

T == T | undefined

---

### TypeScript deficiencies

Many of these features are coming soon.

* <!-- .element: class="fragment" --> `switch` statements
* <!-- .element: class="fragment" --> `async/await`
* <!-- .element: class="fragment" --> Object rest/spread
* <!-- .element: class="fragment" --> [Variance](https://github.com/Microsoft/TypeScript/issues/1394)
* <!-- .element: class="fragment" --> Access to the Babel ecosystem
  * TS does not pick up new features as quickly as Babel.
  * No Plugin infrastructure

---

### Control Flow Type Analysis

```javascript
function bar(x: string | number) {
    if (typeof x === "number") {
        return;
    }
    x; // type of x is string here
}
```
<!-- .element: class="fragment" -->

```javascript
function foo(x: string | number | boolean) {
    if (typeof x === "string") {
        x; // type of x is string here
        x = 1;
        x; // type of x is number here
    }
    x; // type of x is number | boolean here
}
```
<!-- .element: class="fragment" -->


---

### Type Parameters

Type parameters are like variables in types.


<iframe
  data-src="http://localhost:4000/try/#0MYewdgzgLgBBIFsCmBlKAnAlmA5hAXDAILroCGAngDzRa4B8MAvDANoDkAZiCOwLoBuGAHphMYGTAx0SBCABuSGFAAWmCAChRMABTxkaOnkIly1MAFcEAIyTp6ASgEatYgLRuYLgCZJgAGzIZcUCICGIAWTIAByoAFUYAbw0YGG8yKDJCRNYAayQKQlpsHD5COIBfIW1QC39vGAQyfOU1cKQyCEw7FJgcJChCHXzCuAwSh2ZGOOdUiAGhkaLx3AAaGHkyf3LJpkZ5EExvZwqXbQ8vDVBIWGLcKOiTB5oVnEYWMCQAd0iYnScNHccA8AHTzKA6Lg8djrdjWILsAHXaAwazMMZGUH9CFQ3hOERiMgWKCIDKYCT+fwUGDYTh2GQNTowAAGQOZgNeoPSmQ41kwnE4-HRuPY1TE3kwMmAsDIwGASDCCpgQSUUAo0SQ3g0QA"
  width="90%"
  height="600px"
></iframe>

---

### Invariance, Covariance, Contravariance

For a type `T`, a type that is:

* Invariant: Accepts only the exact type, not subtypes or supertypes <!-- .element: class="fragment" -->
* Covariant: Accepts the type and subtypes <!-- .element: class="fragment" -->
  * Animal is covariant to Cat
* Contravariant: Accepts the type and supertypes <!-- .element: class="fragment" -->
  * Cat is contravariant to Animal

---

### Variance on Arrays

Array puts/constructions are `covariant`:

```javascript
const animals: Array<Animal> = [new Cat(), new Dog()]; // Fine!
animals.push(new Snake());
```
<!-- .element: class="fragment" -->

<span class="fragment">Array getters are `contravariant`:</span>

```javascript
const cats = Array<Cat> = [new Kitten(), new Cat()];
const garfield: Animal = cats[0]; // Fine!
const kitty: Kitten = cats[1]; // Error! Can't assume a subtype when getting
```
<!-- .element: class="fragment" -->

---

### Variance Support

* TypeScript treats all arrays as Covariant
  <!-- From "[TypeScript does not yet correctly type programs](http://www.mikaelmayer.com/2015/02/02/typescript-does-not-yet-correctly-type-check-programs/)" -->

  <blockquote style="font-size: 16px">
  ...Typescript does not set up type equations or type constraints.
  It solves equations in a greedy manner, without back-tracking.
  Although this is viable for small programs, this does not scale and it's a shame.
  </blockquote>

<iframe
  data-src="http://localhost:4000/try/#0MYGwhgzhAECCB2BLAtmE0DeBfAUKSMAEgPYBOEAptBQB4AuF8AJjAimprvlNAMrxgA1lVoNmrJKnQYc0OdAghEdABYVSACgCUmWfP1p1dDQCJeS1esTwA5gEITWvXNy4cANzCloYAFx8BYQBtAF1oAF5oIPgKAHcAoQptEI8vaAAjfzYpUIifAG4cdKCABjDImPiSciStQrBSkIA6RWU1TTqcHCA"
  width="90%"
  height="500px"
></iframe>

Note: Generics were only added in TS 1.4

---

### `this` Types

```javascript
interface UIElement {
  addClickListener(onclick: (this: void, e: Event) => void): void;
}
function badFn() {
  this.emit('foo');
}
uiElement.addClickListener(h.onClickBad); // error!
```

Note: This is TS-only. Has options to warn on implicit uses of this (nice!)

---

### Syntax Differences

* `?number` vs `number | null`

```javascript
// TS
function assign<T extends U, U>(target: T, source: U): T {
    for (let id in source) {
        target[id] = source[id];
    }
    return target;
}

let x = { a: 1, b: 2, c: 3, d: 4 };
assign(x, { b: 10, d: 20 });
assign(x, { e: 0 });  // Error
```

```javascript
/* @flow */

function assign<T: Object, U: $Shape<T>>(target: T, source: U): T {
    for (let id in source) {
        target[id] = source[id];
    }
    return target;
}

let x = { a: 1, b: 2, c: 3, d: 4 };
assign(x, { b: 10, d: 20 });
assign(x, { e: 0 });  // Error
```

---

### Using Types in Flux Apps

<iframe
  data-src="http://localhost:4000/try/#0PTAEBUE8AcEsGMCGAbUj4BdYHsB2BnUePfDRXDQgEwFMAzWXWLPAKBFAGFsBXZKtMnzZQAIxppQyWKVDY6oAAY0AHtGwAnDERIZFrYgW3gA8gBETAfQCCncAEkTAOQDKoALygA3q1ChrZmaWphYAXKAA5AFBISYRADS+oACiZvbgweYm4RGp6ZkWCUmcJgCyAAoAMsngyQXZkSUV1bX1RQC+ANys7GAAJADSNJD4ADzgAHygMpIAtogA5gigGDASGAAWiNrwGjTbNISIoDxMeHIKzITQiBqIszQYNBoRhADWw-i9oIOf41PuTxRQJtUAAH0ieQysQi4MaZSqNTqMNYq2gEmsmBwuA8PyGI1GaJo8ggWRsdkcrgm3Vo8GQtwkdFOWPOVBkNww8A2AAp0CxcOFMfz4qAbpBkNhEFRwiZRAArGiYACU4QAbthYFRuqw2fgOVzuREmuVkpVWjCRV5NeEAIztJWdUAcbDYaD4ACEQA"
  width="90%"
  height="600px"
></iframe>

---

### Typing External Libraries

Both Flow & TypeScript have typing repositories.

* 2017 definitions in DefinitelyTyped
![](/img/definitelytyped.jpg)

* 114 in Flow-Typed
```sh
~/g/f/f/d/npm (master|✔) $ find . -type d -maxdepth 1 | wc -l
     114
```

```javascript
declare module 'lodash' {
  // ...
  find<T>(array: ?Array<T>, predicate?: Predicate<T>): T;
  // ...
}
```

---


### Which Should I Use?

<div style="display: flex">
<div style="width: 50%">
  <h4>TypeScript</h4>
  <ul style="font-size: 24px">
    <li class="fragment">You value strong tooling integration</li>
    <li class="fragment">You are starting a new project from scratch</li>
    <li class="fragment">You want to take advantage of more mature integrations & typedefs</li>
  </ul>
</div>

<div style="width: 50%">
  <h4>Flow</h4>
  <ul style="font-size: 24px">
    <li class="fragment">You have an existing project</li>
    <li class="fragment">You are using React</li>
    <li class="fragment">You want to use Babel now or later</li>
    <li class="fragment">You like Camels, and especially OCamls</li>
  </ul>
</div>
</div>

<div style="display:flex;height:300px;margin-top:20px">
  <img class="fragment" src="/img/dreams.gif" />
  <img class="fragment" src="/img/just_do_it.gif" />
</div>

---

### Questions?

* @STRML_
* github.com/STRML
